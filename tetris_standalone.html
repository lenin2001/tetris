<!DOCTYPE html>
<html>
<head>
    <title>Тетрис</title>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <style>
        body {
            background: linear-gradient(135deg, #6e45e2, #88d3ce);
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            font-family: Arial, sans-serif;
            color: white;
            overflow: hidden;
        }
        
        .game-container {
            display: flex;
            flex-direction: row;
            gap: 20px;
            background: rgba(0, 0, 0, 0.2);
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            max-width: 900px;
            width: 100%;
        }
        
        .info-panel {
            display: flex;
            flex-direction: column;
            gap: 20px;
            width: 200px;
        }
        
        .score-box {
            background: rgba(255, 255, 255, 0.1);
            padding: 15px;
            border-radius: 8px;
        }
        
        h1 {
            font-size: 2em;
            margin: 0 0 20px 0;
            text-align: center;
            animation: pulse 2s infinite;
        }
        
        canvas {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 5px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
            image-rendering: pixelated;
        }
        
        button {
            background: linear-gradient(45deg, #ff6b6b, #ff8e53);
            border: none;
            padding: 12px 20px;
            font-size: 1.2em;
            color: white;
            border-radius: 5px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            width: 100%;
            font-weight: bold;
        }
        
        button:hover {
            transform: translateY(-3px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
        }
        
        button:active {
            transform: translateY(0);
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        }
        
        .controls-info {
            background: rgba(255, 255, 255, 0.1);
            padding: 15px;
            border-radius: 8px;
        }
        
        .controls-info h3 {
            margin-top: 0;
            text-align: center;
        }
        
        .controls-info p {
            margin: 8px 0;
        }
        
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }
        
        .sparkle {
            position: absolute;
            width: 5px;
            height: 5px;
            background: white;
            border-radius: 50%;
            animation: sparkle 1s infinite;
        }
        
        @keyframes sparkle {
            0% { opacity: 0.2; }
            50% { opacity: 1; }
            100% { opacity: 0.2; }
        }
        
        @media (max-width: 768px) {
            body {
                padding: 10px;
                height: auto;
                min-height: 100vh;
                overflow-y: auto; /* Разрешаем вертикальную прокрутку */
            }
            
            .game-container {
                flex-direction: column;
                align-items: center;
                padding: 10px;
                max-width: 100%;
                box-sizing: border-box;
                margin-bottom: 20px; /* Добавляем отступ снизу */
            }
            
            .info-panel {
                width: 100%;
                max-width: 300px;
                order: 2;
            }
            
            canvas#tetris {
                max-width: 100%;
                height: auto !important; /* Принудительно устанавливаем автоматическую высоту */
                order: 1;
                transform: scale(0.65); /* Значительно уменьшаем размер для лучшей видимости */
                transform-origin: top center;
                margin-bottom: 40px; /* Увеличиваем отступ снизу */
            }
            
            h1 {
                font-size: 1.5em;
                margin-bottom: 10px;
            }
            
            .controls-info {
                font-size: 0.9em;
            }
            
            button {
                padding: 10px;
                font-size: 1em;
            }
            
            /* Уменьшаем размер игрового поля для мобильных устройств */
            @media (max-height: 800px) {
                canvas#tetris {
                    transform: scale(0.5); /* Еще сильнее уменьшаем для низких экранов */
                    margin-bottom: 0;
                }
                
                .game-container {
                    margin-bottom: 60px; /* Увеличиваем отступ снизу */
                }
                
                body {
                    padding-bottom: 80px; /* Добавляем отступ снизу для всей страницы */
                }
            }
            
            /* Дополнительные стили для очень маленьких экранов */
            @media (max-height: 600px) {
                canvas#tetris {
                    transform: scale(0.4); /* Максимальное уменьшение для очень маленьких экранов */
                }
                
                .mobile-controls {
                    margin-top: 5px; /* Уменьшаем отступ сверху для кнопок */
                }
                
                .mobile-controls button {
                    width: 60px;
                    height: 60px;
                }
                
                #rotate-btn, #drop-btn {
                    width: 120px;
                }
            }
        }
        
        /* Настройки для мобильных устройств */
        html, body {
            overscroll-behavior: contain;
            touch-action: pan-y; /* Разрешаем вертикальную прокрутку */
            scroll-behavior: smooth; /* Плавная прокрутка */
        }
        
        /* Дополнительные стили для улучшения видимости на мобильных */
        @media (max-width: 768px) {
            .game-wrapper {
                position: relative;
                width: 100%;
                overflow: visible;
            }
            
            /* Добавляем индикатор прокрутки для мобильных устройств */
            .scroll-indicator {
                display: none; /* По умолчанию скрыт */
                position: fixed;
                bottom: 10px;
                left: 50%;
                transform: translateX(-50%);
                background: rgba(255, 255, 255, 0.2);
                color: white;
                padding: 5px 10px;
                border-radius: 20px;
                font-size: 12px;
                z-index: 1000;
                animation: pulse 2s infinite;
                transition: opacity 0.5s;
            }
            
            /* Показываем индикатор только на мобильных устройствах */
            @media (max-width: 768px) {
                .scroll-indicator {
                    display: block;
                }
            }
            
            @keyframes pulse {
                0% { opacity: 0.5; }
                50% { opacity: 1; }
                100% { opacity: 0.5; }
            }
        }
        
        /* Стили для мобильных кнопок управления */
        .mobile-controls {
            display: none; /* По умолчанию скрыты */
            flex-direction: column;
            gap: 15px;
            margin-top: 20px;
            width: 100%;
            max-width: 300px;
        }
        
        .mobile-controls-row {
            display: flex;
            justify-content: center;
            gap: 15px;
        }
        
        .mobile-controls button {
            width: 70px;
            height: 70px;
            font-size: 28px;
            border-radius: 50%;
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.3), rgba(255, 255, 255, 0.1));
            color: white;
            border: 3px solid rgba(255, 255, 255, 0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 0;
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.3);
            cursor: pointer;
            -webkit-tap-highlight-color: transparent; /* Убираем подсветку при тапе на мобильных */
            user-select: none; /* Запрещаем выделение текста */
            transition: transform 0.1s, background 0.1s, box-shadow 0.1s;
        }
        
        .mobile-controls button:active {
            transform: scale(0.9) translateY(4px);
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.4), rgba(255, 255, 255, 0.2));
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }
        
        #rotate-btn, #drop-btn {
            width: 140px;
            border-radius: 35px;
            font-weight: bold;
        }
        
        #left-btn {
            background: linear-gradient(135deg, rgba(0, 116, 217, 0.7), rgba(0, 116, 217, 0.4));
            border-color: rgba(0, 116, 217, 0.8);
        }
        
        #right-btn {
            background: linear-gradient(135deg, rgba(0, 116, 217, 0.7), rgba(0, 116, 217, 0.4));
            border-color: rgba(0, 116, 217, 0.8);
        }
        
        #down-btn {
            background: linear-gradient(135deg, rgba(255, 133, 27, 0.7), rgba(255, 133, 27, 0.4));
            border-color: rgba(255, 133, 27, 0.8);
        }
        
        #rotate-btn {
            background: linear-gradient(135deg, rgba(46, 204, 64, 0.7), rgba(46, 204, 64, 0.4));
            border-color: rgba(46, 204, 64, 0.8);
        }
        
        #drop-btn {
            background: linear-gradient(135deg, rgba(255, 65, 54, 0.7), rgba(255, 65, 54, 0.4));
            border-color: rgba(255, 65, 54, 0.8);
        }
        
        /* Показываем мобильные кнопки только на мобильных устройствах */
        @media (max-width: 768px) {
            .mobile-controls {
                display: flex;
                order: 3;
            }
        }
    </style>
</head>
<body>
    <div class="game-container">
        <div class="game-wrapper">
            <canvas id="tetris" width="500" height="1000"></canvas>
            <div class="scroll-indicator" id="scroll-indicator">Прокрутите вниз для полного обзора</div>
        </div>
        
        <!-- Мобильные кнопки управления -->
        <div class="mobile-controls">
            <div class="mobile-controls-row">
                <button id="rotate-btn">↑</button>
            </div>
            <div class="mobile-controls-row">
                <button id="left-btn">←</button>
                <button id="down-btn">↓</button>
                <button id="right-btn">→</button>
            </div>
            <div class="mobile-controls-row">
                <button id="drop-btn">⬇️⬇️</button>
            </div>
        </div>
        
        <div class="info-panel">
            <h1>✨ Тетрис ✨</h1>
            
            <div class="score-box">
                <p>🏆 Счет: <span id="score">0</span></p>
                <p>📊 Линии: <span id="lines">0</span></p>
                <p>🚀 Уровень: <span id="level">1</span></p>
            </div>
            
            <div class="score-box">
                <p>🎲 Следующая фигура:</p>
                <canvas id="next" width="120" height="120"></canvas>
            </div>
            
            <button id="start">▶️ СТАРТ</button>
            
            <div class="controls-info">
                <h3>🎮 Управление:</h3>
                <p>← → : Движение влево/вправо</p>
                <p>↑ : Вращение</p>
                <p>↓ : Движение вниз</p>
                <p>Пробел : Сбросить фигуру</p>
                <p>P : Пауза</p>
                <p>Двойной клик: Старт/Пауза</p>
                <h3>📱 Мобильное управление:</h3>
                <p>Свайп влево/вправо: Движение</p>
                <p>Свайп вверх: Вращение</p>
                <p>Свайп вниз: Сбросить фигуру</p>
                <p>Тап: Движение вниз</p>
                <p>Двойной тап: Старт/Пауза</p>
                <p>Также доступны кнопки управления</p>
            </div>
        </div>
    </div>

    <script>
        // Получаем элементы
        const canvas = document.getElementById('tetris');
        const context = canvas.getContext('2d');
        const nextCanvas = document.getElementById('next');
        const nextContext = nextCanvas.getContext('2d');
        const startButton = document.getElementById('start');
        
        // Константы
        const BLOCK_SIZE = 25; // Размер блока
        const ROWS = 40;       // Увеличиваем количество рядов в 2 раза (было 20)
        const COLS = 20;       // Широкий стакан
        
        // Настраиваем размер холста для идеальных квадратов
        canvas.style.width = `${COLS * BLOCK_SIZE}px`;
        canvas.style.height = `${ROWS * BLOCK_SIZE}px`;
        
        // Переменные состояния
        let dropCounter = 0;
        let dropInterval = 1000;
        let lastTime = 0;
        let score = 0;
        let lines = 0;
        let level = 1;
        let paused = false;
        let gameOver = true;
        
        // Создаем игровое поле
        const arena = createMatrix(COLS, ROWS);
        
        // Игрок
        const player = {
            pos: {x: 0, y: 0},
            matrix: null,
            next: null,
            score: 0
        };
        
        // Цвета фигур с градиентами (3D-эффект)
        const colors = [
            null,
            {main: '#FF4136', light: '#FF725C', dark: '#E7040F'}, // Красный
            {main: '#2ECC40', light: '#9EEBCF', dark: '#137752'}, // Зеленый
            {main: '#0074D9', light: '#7FDBFF', dark: '#00449E'}, // Синий
            {main: '#FFDC00', light: '#FFFCEB', dark: '#FFD700'}, // Желтый
            {main: '#B10DC9', light: '#F6D8FF', dark: '#5E2CA5'}, // Фиолетовый
            {main: '#FF851B', light: '#FFE8D9', dark: '#D86E00'}, // Оранжевый
            {main: '#01FF70', light: '#E8FDF5', dark: '#00A86B'},  // Бирюзовый
            {main: '#F012BE', light: '#FFCEF3', dark: '#85144b'}, // Розовый
            {main: '#7FDBFF', light: '#E4F9FF', dark: '#0074D9'}, // Голубой
            {main: '#39CCCC', light: '#E5FFFF', dark: '#2EAD88'}, // Аквамарин
            {main: '#3D9970', light: '#C4F9EB', dark: '#1A5336'}, // Оливковый
            {main: '#AAAAAA', light: '#EEEEEE', dark: '#666666'}, // Серый
            {main: '#FF4136', light: '#FF725C', dark: '#E7040F'}, // Красный (повтор)
            {main: '#2ECC40', light: '#9EEBCF', dark: '#137752'}  // Зеленый (повтор)
        ];
        
        // Стандартные фигуры Тетриса
        const standardPieces = [
            // T-образная фигура
            [
                [0, 1, 0],
                [1, 1, 1]
            ],
            // L-образная фигура
            [
                [0, 0, 2],
                [2, 2, 2]
            ],
            // J-образная фигура
            [
                [3, 0, 0],
                [3, 3, 3]
            ],
            // Квадрат
            [
                [4, 4],
                [4, 4]
            ],
            // Z-образная фигура
            [
                [5, 5, 0],
                [0, 5, 5]
            ],
            // Перевернутая T-образная фигура
            [
                [0, 6, 0],
                [6, 6, 6]
            ],
            // S-образная фигура
            [
                [0, 7, 7],
                [7, 7, 0]
            ],
            // I-образная фигура (линия)
            [
                [8, 8, 8, 8]
            ]
        ];
        
        // Дополнительные рандомные фигуры размером от 1 до 4 блоков
        const additionalPieces = [
            // Одиночный блок
            [
                [9]
            ],
            // Двойные блоки (горизонтальные и вертикальные)
            [
                [10, 10]
            ],
            [
                [11],
                [11]
            ],
            // Тройные блоки (разные формы)
            [
                [12, 12, 12]
            ],
            [
                [13],
                [13],
                [13]
            ],
            [
                [14, 14],
                [14, 0]
            ],
            [
                [15, 15],
                [0, 15]
            ]
        ];
        
        // Фигуры из 5 блоков
        const pentominoePieces = [
            // I-пентомино (длинная линия)
            [
                [1, 1, 1, 1, 1]
            ],
            // L-пентомино
            [
                [2, 0, 0, 0],
                [2, 2, 2, 2]
            ],
            // J-пентомино
            [
                [0, 0, 0, 3],
                [3, 3, 3, 3]
            ],
            // T-пентомино
            [
                [0, 4, 0],
                [0, 4, 0],
                [4, 4, 4]
            ],
            // U-пентомино
            [
                [5, 0, 5],
                [5, 5, 5]
            ],
            // X-пентомино (крест)
            [
                [0, 6, 0],
                [6, 6, 6],
                [0, 6, 0]
            ],
            // Z-пентомино
            [
                [7, 7, 0],
                [0, 7, 0],
                [0, 7, 7]
            ],
            // S-пентомино
            [
                [0, 8, 8],
                [0, 8, 0],
                [8, 8, 0]
            ],
            // P-пентомино
            [
                [9, 9],
                [9, 9],
                [9, 0]
            ],
            // F-пентомино
            [
                [0, 10, 10],
                [10, 10, 0],
                [0, 10, 0]
            ]
        ];
        
        // Объединяем все фигуры
        const pieces = [...standardPieces, ...additionalPieces, ...pentominoePieces];
        
        // Функции
        function createMatrix(w, h) {
            const matrix = [];
            while (h--) {
                matrix.push(new Array(w).fill(0));
            }
            return matrix;
        }
        
        function createPiece(type) {
            try {
                console.log("Создание фигуры типа:", type);
                
                // Проверяем корректность типа
                if (type < 0 || type >= pieces.length) {
                    console.error("Некорректный тип фигуры:", type, "максимальный индекс:", pieces.length - 1);
                    // Возвращаем квадрат (индекс 3) как запасной вариант
                    return JSON.parse(JSON.stringify(pieces[3]));
                }
                
                // Проверяем, что pieces[type] существует и является массивом
                if (!pieces[type] || !Array.isArray(pieces[type])) {
                    console.error("Фигура с индексом", type, "не существует или не является массивом:", pieces[type]);
                    // Возвращаем квадрат (индекс 3) как запасной вариант
                    return JSON.parse(JSON.stringify(pieces[3]));
                }
                
                // Создаем глубокую копию фигуры
                const piece = JSON.parse(JSON.stringify(pieces[type]));
                
                // Проверяем, что фигура создана корректно
                if (!Array.isArray(piece) || piece.length === 0) {
                    console.error("Ошибка при создании фигуры:", piece);
                    // Возвращаем простую фигуру как запасной вариант
                    return [[1]];
                }
                
                console.log("Фигура создана успешно, размер:", piece.length, "x", piece[0].length);
                return piece;
            } catch (e) {
                console.error("Ошибка в createPiece:", e, "stack:", e.stack);
                // Возвращаем простую фигуру как запасной вариант
                return [[1]];
            }
        }
        
        function drawMatrix(matrix, offset, ctx) {
            matrix.forEach((row, y) => {
                row.forEach((value, x) => {
                    if (value !== 0) {
                        // Получаем цвета для текущего блока
                        const colorIndex = value % colors.length;
                        const colorSet = colors[colorIndex === 0 ? 1 : colorIndex];
                        
                        // Рисуем основной блок
                        ctx.fillStyle = colorSet.main;
                        ctx.fillRect(
                            (x + offset.x) * BLOCK_SIZE,
                            (y + offset.y) * BLOCK_SIZE,
                            BLOCK_SIZE, BLOCK_SIZE
                        );
                        
                        // Добавляем блеск (светлая часть)
                        ctx.fillStyle = colorSet.light;
                        ctx.fillRect(
                            (x + offset.x) * BLOCK_SIZE,
                            (y + offset.y) * BLOCK_SIZE,
                            BLOCK_SIZE, BLOCK_SIZE / 4
                        );
                        
                        // Добавляем тень (темная часть)
                        ctx.fillStyle = colorSet.dark;
                        ctx.fillRect(
                            (x + offset.x) * BLOCK_SIZE,
                            (y + offset.y) * BLOCK_SIZE + BLOCK_SIZE * 3/4,
                            BLOCK_SIZE, BLOCK_SIZE / 4
                        );
                        
                        // Рисуем границу блока
                        ctx.strokeStyle = 'rgba(0, 0, 0, 0.3)';
                        ctx.lineWidth = 1;
                        ctx.strokeRect(
                            (x + offset.x) * BLOCK_SIZE,
                            (y + offset.y) * BLOCK_SIZE,
                            BLOCK_SIZE, BLOCK_SIZE
                        );
                    }
                });
            });
        }
        
        function draw() {
            // Очищаем холст
            context.fillStyle = 'rgba(0, 0, 0, 0.3)';
            context.fillRect(0, 0, canvas.width, canvas.height);
            
            // Рисуем сетку
            context.strokeStyle = 'rgba(255, 255, 255, 0.1)';
            context.lineWidth = 1;
            
            for (let x = 0; x <= COLS; x++) {
                context.beginPath();
                context.moveTo(x * BLOCK_SIZE, 0);
                context.lineTo(x * BLOCK_SIZE, ROWS * BLOCK_SIZE);
                context.stroke();
            }
            
            for (let y = 0; y <= ROWS; y++) {
                context.beginPath();
                context.moveTo(0, y * BLOCK_SIZE);
                context.lineTo(COLS * BLOCK_SIZE, y * BLOCK_SIZE);
                context.stroke();
            }
            
            // Рисуем арену
            drawMatrix(arena, {x: 0, y: 0}, context);
            
            // Рисуем текущую фигуру
            if (player.matrix) {
                drawMatrix(player.matrix, player.pos, context);
            }
            
            // Рисуем следующую фигуру
            nextContext.fillStyle = 'rgba(0, 0, 0, 0.3)';
            nextContext.fillRect(0, 0, nextCanvas.width, nextCanvas.height);
            
            if (player.next) {
                const offset = {
                    x: (nextCanvas.width / BLOCK_SIZE - player.next[0].length) / 2,
                    y: (nextCanvas.height / BLOCK_SIZE - player.next.length) / 2
                };
                drawMatrix(player.next, offset, nextContext);
            }
            
            // Отображаем паузу
            if (paused) {
                context.fillStyle = 'rgba(0, 0, 0, 0.7)';
                context.fillRect(0, 0, canvas.width, canvas.height);
                
                context.font = '30px Arial';
                context.fillStyle = 'white';
                context.textAlign = 'center';
                context.fillText('ПАУЗА', canvas.width / 2, canvas.height / 2);
            }
            
            // Отображаем подсказку о двойном клике, если игра не начата
            if (gameOver) {
                context.fillStyle = 'rgba(0, 0, 0, 0.7)';
                context.fillRect(0, 0, canvas.width, canvas.height);
                
                context.font = '30px Arial';
                context.fillStyle = 'white';
                context.textAlign = 'center';
                context.fillText('ТЕТРИС', canvas.width / 2, canvas.height / 2 - 40);
                
                context.font = '20px Arial';
                context.fillStyle = 'rgba(255, 255, 255, 0.8)';
                context.fillText('Двойной клик для начала игры', canvas.width / 2, canvas.height / 2 + 20);
                
                // Анимированная подсказка
                const pulseSize = 1 + 0.1 * Math.sin(Date.now() / 300);
                context.font = `${Math.floor(24 * pulseSize)}px Arial`;
                context.fillStyle = 'rgba(255, 255, 255, 0.9)';
                context.fillText('👆 👆', canvas.width / 2, canvas.height / 2 + 70);
            }
        }
        
        function merge(arena, player) {
            try {
                // Проверяем, что все необходимые параметры определены
                if (!arena || !player || !player.matrix || !player.pos) {
                    console.error("Ошибка в merge: некорректные параметры", 
                                 "arena:", arena, 
                                 "player:", player);
                    return;
                }
                
                // Проверяем, что матрица фигуры корректна
                if (!Array.isArray(player.matrix) || player.matrix.length === 0) {
                    console.error("Ошибка в merge: некорректная матрица фигуры", player.matrix);
                    return;
                }
                
                console.log("Объединение фигуры с ареной на позиции:", player.pos);
                
                // Объединяем фигуру с ареной
                player.matrix.forEach((row, y) => {
                    row.forEach((value, x) => {
                        if (value !== 0) {
                            // Проверяем, что позиция находится в пределах арены
                            if (arena[y + player.pos.y] !== undefined && 
                                arena[y + player.pos.y][x + player.pos.x] !== undefined) {
                                arena[y + player.pos.y][x + player.pos.x] = value;
                            } else {
                                console.error("Ошибка в merge: попытка записи за пределами арены", 
                                             "y:", y + player.pos.y, 
                                             "x:", x + player.pos.x);
                            }
                        }
                    });
                });
                
                console.log("Объединение завершено успешно");
            } catch (e) {
                console.error("Ошибка при объединении фигуры с ареной:", e, "stack:", e.stack);
            }
        }
        
        function collide(arena, player) {
            try {
                // Проверяем, что все необходимые параметры определены
                if (!arena || !player || !player.matrix || !player.pos) {
                    console.error("Ошибка в collide: некорректные параметры", 
                                 "arena:", arena, 
                                 "player:", player);
                    return true; // Считаем, что столкновение есть, чтобы избежать ошибок
                }
                
                const m = player.matrix;
                const o = player.pos;
                
                // Проверяем, что матрица фигуры корректна
                if (!Array.isArray(m) || m.length === 0 || !Array.isArray(m[0])) {
                    console.error("Ошибка в collide: некорректная матрица фигуры", m);
                    return true;
                }
                
                // Проверяем каждую ячейку фигуры
                for (let y = 0; y < m.length; ++y) {
                    for (let x = 0; x < m[y].length; ++x) {
                        // Если ячейка фигуры не пуста, проверяем на столкновение
                        if (m[y][x] !== 0) {
                            // Проверяем выход за границы арены или столкновение с другими блоками
                            if (arena[y + o.y] === undefined || // Выход за нижнюю или верхнюю границу
                                arena[y + o.y][x + o.x] === undefined || // Выход за боковые границы
                                arena[y + o.y][x + o.x] !== 0) { // Столкновение с другими блоками
                                
                                return true;
                            }
                        }
                    }
                }
                
                // Если столкновений не обнаружено
                return false;
            } catch (e) {
                console.error("Ошибка при проверке столкновений:", e, "stack:", e.stack);
                return true; // В случае ошибки считаем, что столкновение есть
            }
        }
        
        function rotate(matrix, dir) {
            // Создаем новую матрицу для результата вращения
            const N = matrix.length;
            const M = matrix[0].length;
            let result = [];
            
            if (dir > 0) { // По часовой стрелке
                for (let i = 0; i < M; i++) {
                    let newRow = [];
                    for (let j = N - 1; j >= 0; j--) {
                        newRow.push(matrix[j][i]);
                    }
                    result.push(newRow);
                }
            } else { // Против часовой стрелки
                for (let i = M - 1; i >= 0; i--) {
                    let newRow = [];
                    for (let j = 0; j < N; j++) {
                        newRow.push(matrix[j][i]);
                    }
                    result.push(newRow);
                }
            }
            
            // Создаем новую матрицу вместо изменения исходной
            const rotatedMatrix = [];
            for (let i = 0; i < result.length; i++) {
                rotatedMatrix.push([...result[i]]);
            }
            
            // Заменяем содержимое исходной матрицы
            matrix.length = 0; // Очищаем исходную матрицу
            for (let i = 0; i < rotatedMatrix.length; i++) {
                matrix.push(rotatedMatrix[i]);
            }
        }
        
        function playerRotate(dir) {
            const originalPos = {
                x: player.pos.x,
                y: player.pos.y
            };
            
            // Сохраняем оригинальную матрицу
            const originalMatrix = JSON.parse(JSON.stringify(player.matrix));
            
            // Вращаем матрицу
            rotate(player.matrix, dir);
            
            // Проверяем, не выходит ли фигура за правую границу
            const rightOverhang = player.pos.x + player.matrix[0].length - COLS;
            if (rightOverhang > 0) {
                player.pos.x -= rightOverhang;
            }
            
            // Проверяем, не выходит ли фигура за левую границу
            if (player.pos.x < 0) {
                player.pos.x = 0;
            }
            
            // Проверяем, не выходит ли фигура за нижнюю границу
            const bottomOverhang = player.pos.y + player.matrix.length - ROWS;
            if (bottomOverhang > 0) {
                player.pos.y -= bottomOverhang;
            }
            
            // Пытаемся найти позицию, где фигура не будет сталкиваться
            let offset = 1;
            let attempts = 0;
            const maxAttempts = Math.max(player.matrix[0].length, player.matrix.length) * 2;
            
            while (collide(arena, player)) {
                player.pos.x += offset;
                offset = -(offset + (offset > 0 ? 1 : -1));
                attempts++;
                
                // Если не можем разместить фигуру после вращения по горизонтали,
                // пробуем сдвинуть вверх
                if (Math.abs(offset) > player.matrix[0].length) {
                    player.pos.x = originalPos.x;
                    player.pos.y--;
                    offset = 1;
                }
                
                // Если все попытки не удались, возвращаем исходную фигуру
                if (attempts > maxAttempts) {
                    player.matrix = originalMatrix;
                    player.pos.x = originalPos.x;
                    player.pos.y = originalPos.y;
                    return;
                }
            }
        }
        
        function playerDrop() {
            try {
                // Проверяем состояние игры
                if (gameOver || paused) {
                    console.log("Игра окончена или на паузе, пропускаем playerDrop");
                    return;
                }
                
                // Проверяем, что player и его свойства определены
                if (!player || !player.pos || !player.matrix) {
                    console.error("Ошибка: player не определен или некорректен", player);
                    return;
                }
                
                // Перемещаем фигуру вниз
                player.pos.y++;
                
                // Проверяем на столкновение
                if (collide(arena, player)) {
                    console.log("Обнаружено столкновение при падении");
                    
                    // Возвращаем фигуру на предыдущую позицию
                    player.pos.y--;
                    
                    // Объединяем фигуру с ареной
                    merge(arena, player);
                    
                    // После очистки заполненных линий создаем новую фигуру
                    arenaSweep(() => {
                        const ended = playerReset();
                        if (!ended) {
                            updateScore();
                        }
                    });
                }
                
                // Сбрасываем счетчик падения
                dropCounter = 0;
            } catch (e) {
                console.error("Ошибка в playerDrop:", e, "stack:", e.stack);
                dropCounter = 0;
            }
        }
        
        function playerMove(offset) {
            player.pos.x += offset;
            if (collide(arena, player)) {
                player.pos.x -= offset;
            }
        }
        
        function playerHardDrop() {
            try {
                // Проверяем состояние игры
                if (gameOver || paused) {
                    console.log("Игра окончена или на паузе, пропускаем playerHardDrop");
                    return;
                }
                
                // Проверяем, что player и его свойства определены
                if (!player || !player.pos || !player.matrix) {
                    console.error("Ошибка: player не определен или некорректен", player);
                    return;
                }
                
                console.log("Выполняем быстрое падение");
                
                // Перемещаем фигуру вниз до столкновения
                let dropDistance = 0;
                while (!collide(arena, player)) {
                    player.pos.y++;
                    dropDistance++;
                    
                    // Защита от бесконечного цикла
                    if (dropDistance > 100) {
                        console.error("Обнаружен бесконечный цикл в playerHardDrop");
                        break;
                    }
                }
                
                // Возвращаем фигуру на последнюю валидную позицию
                player.pos.y--;
                
                // Объединяем фигуру с ареной
                merge(arena, player);
                
                arenaSweep(() => {
                    const ended = playerReset();
                    if (!ended) {
                        updateScore();
                    }
                });

                // Сбрасываем счетчик падения
                dropCounter = 0;
                
                console.log("Быстрое падение завершено, пройдено клеток:", dropDistance);
            } catch (e) {
                console.error("Ошибка в playerHardDrop:", e, "stack:", e.stack);
                dropCounter = 0;
            }
        }
        
        function playerReset() {
            try {
                console.log("Вызов playerReset...");
                
                // Проверяем, что player определен
                if (!player) {
                    console.error("Ошибка: player не определен");
                    player = {
                        pos: {
                            x: 0,
                            y: 0
                        },
                        matrix: null,
                        next: null,
                        score: 0
                    };
                }
                
                // Устанавливаем следующую фигуру как текущую
                if (!player.next) {
                    console.log("Создаем новую текущую фигуру");
                    const pieceIndex = Math.floor(Math.random() * pieces.length);
                    player.matrix = createPiece(pieceIndex);
                    console.log("Создана фигура с индексом:", pieceIndex);
                } else {
                    console.log("Используем следующую фигуру как текущую");
                    player.matrix = player.next;
                }
                
                // Создаем новую следующую фигуру
                const nextPieceIndex = Math.floor(Math.random() * pieces.length);
                player.next = createPiece(nextPieceIndex);
                console.log("Создана следующая фигура с индексом:", nextPieceIndex);
                
                // Проверяем, что матрица фигуры создана корректно
                if (!player.matrix || !Array.isArray(player.matrix) || player.matrix.length === 0) {
                    console.error("Ошибка: некорректная матрица фигуры", player.matrix);
                    player.matrix = createPiece(0); // Создаем фигуру T как запасной вариант
                }
                
                // Сбрасываем позицию
                player.pos.y = 0;
                player.pos.x = Math.floor((arena[0].length - player.matrix[0].length) / 2);
                console.log("Установлена начальная позиция:", player.pos);
                
                // Проверка на конец игры
                if (collide(arena, player)) {
                    console.log("Обнаружено столкновение при сбросе игрока - GAME OVER");
                    
                    // Очищаем арену
                    for (let i = 0; i < arena.length; i++) {
                        for (let j = 0; j < arena[i].length; j++) {
                            arena[i][j] = 0;
                        }
                    }
                    
                    // Сбрасываем счет
                    player.score = 0;
                    score = 0;
                    lines = 0;
                    level = 1;
                    updateScore();
                    
                    // Устанавливаем флаг конца игры
                    gameOver = true;
                    paused = false;
                    
                    // Обновляем текст кнопки
                    if (startButton) {
                        startButton.textContent = '▶️ СТАРТ';
                    }
                    
                    // Останавливаем игровой цикл
                    if (animationId !== null) {
                        cancelAnimationFrame(animationId);
                        animationId = null;
                    }
                    
                    // Отображаем сообщение о конце игры
                    if (context) {
                        context.fillStyle = 'rgba(0, 0, 0, 0.7)';
                        context.fillRect(0, 0, canvas.width, canvas.height);
                        
                        context.font = '30px Arial';
                        context.fillStyle = 'white';
                        context.textAlign = 'center';
                        context.fillText('ИГРА ОКОНЧЕНА', canvas.width / 2, canvas.height / 2 - 30);
                        context.fillText('Нажмите СТАРТ для новой игры', canvas.width / 2, canvas.height / 2 + 30);
                    }
                    
                    // Запускаем новый игровой цикл для отображения экрана окончания игры
                    if (animationId === null) {
                        animationId = requestAnimationFrame(update);
                    }
                    
                    console.log("Игра окончена, экран окончания игры отображен");
                    return true; // Возвращаем true, если игра окончена
                }
                
                console.log("playerReset завершен успешно");
                return false; // Возвращаем false, если игра продолжается
            } catch (e) {
                console.error("Ошибка в playerReset:", e, "stack:", e.stack);
                gameOver = true;
                paused = false;
                startButton.textContent = '▶️ СТАРТ';
                return true;
            }
        }
        
        function arenaSweep(callback = () => {}) {
            let rowCount = 0;
            let rowsToRemove = [];
            
            // Находим заполненные строки
            for (let y = arena.length - 1; y >= 0; --y) {
                // Проверяем, что строка существует и полностью заполнена
                if (arena[y] && arena[y].every(value => value !== 0)) {
                    rowsToRemove.push(y);
                    rowCount++;
                }
            }
            
            if (rowCount > 0) {
                // Анимация удаления строк
                animateRowClear(rowsToRemove, () => {
                    try {
                        // Сортируем строки в порядке убывания
                        rowsToRemove.sort((a, b) => b - a);
                        
                        // Удаляем строки
                        rowsToRemove.forEach(y => {
                            // Проверяем, что индекс строки корректный
                            if (y >= 0 && y < arena.length) {
                                arena.splice(y, 1);
                                arena.unshift(new Array(COLS).fill(0));
                            }
                        });
                        
                        // Обновляем счет
                        player.score += rowCount * 10 * level;
                        lines += rowCount;
                        level = Math.floor(lines / 10) + 1;
                        dropInterval = 1000 / level;
                        
                        updateScore();
                        callback();
                    } catch (e) {
                        console.error("Ошибка при удалении строк:", e);
                    }
                });
            } else {
                callback();
            }
        }
        
        function animateRowClear(rows, callback) {
            try {
                let animationStep = 0;
                const totalSteps = 6;
                
                function animate() {
                    try {
                        if (animationStep >= totalSteps) {
                            callback();
                            return;
                        }
                        
                        // Простая анимация мигания строк
                        rows.forEach((y) => {
                            // Проверяем, что индекс строки корректный
                            if (y >= 0 && y < arena.length) {
                                // Чередуем видимость строк (мигание)
                                if (animationStep % 2 === 0) {
                                    // Делаем строку пустой (невидимой)
                                    arena[y].fill(0);
                                } else {
                                    // Возвращаем строку (заполняем единицами для видимости)
                                    arena[y].fill(1);
                                }
                            }
                        });
                        
                        // Отрисовываем текущий кадр
                        draw();
                        
                        // Переходим к следующему шагу анимации
                        animationStep++;
                        setTimeout(animate, 100);
                    } catch (e) {
                        console.error("Ошибка в шаге анимации:", e);
                        callback(); // Вызываем callback в случае ошибки, чтобы игра продолжалась
                    }
                }
                
                animate();
            } catch (e) {
                console.error("Ошибка при запуске анимации:", e);
                callback(); // Вызываем callback в случае ошибки, чтобы игра продолжалась
            }
        }
        
        function updateScore() {
            document.getElementById('score').textContent = player.score;
            document.getElementById('lines').textContent = lines;
            document.getElementById('level').textContent = level;
        }
        
        function togglePause() {
            paused = !paused;
            if (paused) {
                startButton.textContent = '▶️ ПРОДОЛЖИТЬ';
            } else {
                startButton.textContent = '⏸️ ПАУЗА';
            }
        }
        
        let animationId = null;
        
        function update(time = 0) {
            try {
                // Проверяем, что canvas и context определены
                if (!canvas || !context) {
                    console.error("Ошибка: canvas или context не определены в update");
                    
                    // Пробуем получить canvas и context заново
                    canvas = document.getElementById('tetris');
                    context = canvas.getContext('2d');
                    
                    if (!canvas || !context) {
                        console.error("Не удалось получить canvas или context в update");
                        
                        // Останавливаем игровой цикл
                        if (animationId) {
                            cancelAnimationFrame(animationId);
                            animationId = null;
                        }
                        
                        return;
                    }
                }
                
                // Сохраняем текущий animationId для отладки
                const currentAnimationId = animationId;
                
                // Рассчитываем deltaTime
                const deltaTime = time - lastTime;
                lastTime = time;
                
                // Проверяем, что deltaTime имеет разумное значение
                if (deltaTime > 1000) {
                    console.log("Большой deltaTime:", deltaTime, "мс, возможно, вкладка была неактивна");
                    // Ограничиваем deltaTime, чтобы избежать больших скачков
                    lastTime = time;
                    dropCounter = 0;
                }
                
                // Обновляем игровую логику только если игра активна
                if (!gameOver && !paused) {
                    // Проверяем, что player и его свойства определены
                    if (!player || !player.pos || !player.matrix) {
                        console.error("Ошибка: player не определен или некорректен в update", player);
                        
                        // Пробуем восстановить player
                        if (!player) {
                            player = {
                                pos: {
                                    x: 0,
                                    y: 0
                                },
                                matrix: null,
                                next: null,
                                score: 0
                            };
                        }
                        
                        // Пробуем создать новую фигуру
                        if (!player.matrix) {
                            player.matrix = createPiece(Math.floor(Math.random() * pieces.length));
                        }
                        
                        // Пробуем создать следующую фигуру
                        if (!player.next) {
                            player.next = createPiece(Math.floor(Math.random() * pieces.length));
                        }
                        
                        // Устанавливаем начальную позицию
                        player.pos.y = 0;
                        player.pos.x = Math.floor((arena[0].length - player.matrix[0].length) / 2);
                    }
                    
                    // Обновляем счетчик падения
                    dropCounter += deltaTime;
                    
                    // Проверяем, пора ли сбросить фигуру
                    if (dropCounter > dropInterval) {
                        playerDrop();
                    }
                }
                
                // Отрисовываем текущее состояние
                draw();
                
                // Запрашиваем следующий кадр
                if (animationId !== null) {
                    // Если игра не завершена или на паузе, запрашиваем следующий кадр
                    if (!gameOver || paused) {
                        animationId = requestAnimationFrame(update);
                    } else {
                        // Если игра завершена, отрисовываем финальное состояние
                        draw();
                    }
                } else {
                    console.log("animationId равен null, запрашиваем новый кадр");
                    animationId = requestAnimationFrame(update);
                }
                
                // Для отладки
                if (time % 3000 < 20) { // Логируем примерно раз в 3 секунды
                    console.log("Игровой цикл работает, gameOver:", gameOver, "paused:", paused, 
                                "animationId:", animationId, "предыдущий:", currentAnimationId);
                }
            } catch (e) {
                console.error("Ошибка в игровом цикле:", e, "stack:", e.stack);
                
                // Пытаемся восстановить игровой цикл
                if (animationId) {
                    cancelAnimationFrame(animationId);
                }
                
                // Запрашиваем новый кадр с небольшой задержкой
                setTimeout(() => {
                    console.log("Восстанавливаем игровой цикл после ошибки");
                    animationId = requestAnimationFrame(update);
                }, 1000);
            }
        }
        
        // Инициализация игры
        function initGame() {
            try {
                console.log("Инициализация игры...");
                
                // Останавливаем предыдущий игровой цикл, если он был запущен
                if (animationId !== null) {
                    console.log("Отменяем предыдущий animationFrame:", animationId);
                    cancelAnimationFrame(animationId);
                    animationId = null;
                }
                
                // Проверяем, что canvas и context определены
                if (!canvas || !context) {
                    console.error("Ошибка: canvas или context не определены");
                    
                    // Пробуем получить canvas и context заново
                    canvas = document.getElementById('tetris');
                    context = canvas.getContext('2d');
                    
                    if (!canvas || !context) {
                        console.error("Не удалось получить canvas или context");
                        return false;
                    }
                }
                
                // Проверяем, что nextCanvas и nextContext определены
                if (!nextCanvas || !nextContext) {
                    console.error("Ошибка: nextCanvas или nextContext не определены");
                    
                    // Пробуем получить nextCanvas и nextContext заново
                    nextCanvas = document.getElementById('next');
                    nextContext = nextCanvas.getContext('2d');
                    
                    if (!nextCanvas || !nextContext) {
                        console.error("Не удалось получить nextCanvas или nextContext");
                        return false;
                    }
                }
                
                // Проверяем, что startButton определен
                if (!startButton) {
                    console.error("Ошибка: startButton не определен");
                    
                    // Пробуем получить startButton заново
                    startButton = document.getElementById('startButton');
                    
                    if (!startButton) {
                        console.error("Не удалось получить startButton");
                        return false;
                    }
                }
                
                // Проверяем, что arena определена
                if (!arena || !Array.isArray(arena) || arena.length === 0) {
                    console.error("Ошибка: arena не определена или некорректна");
                    
                    // Создаем арену заново
                    arena = createMatrix(COLS, ROWS);
                }
                
                // Проверяем, что player определен
                if (!player) {
                    console.error("Ошибка: player не определен");
                    
                    // Создаем player заново
                    player = {
                        pos: {
                            x: 0,
                            y: 0
                        },
                        matrix: null,
                        next: null,
                        score: 0
                    };
                }
                
                // Очищаем арену
                for (let i = 0; i < arena.length; i++) {
                    for (let j = 0; j < arena[i].length; j++) {
                        arena[i][j] = 0;
                    }
                }
                
                // Сбрасываем счет
                player.score = 0;
                score = 0;
                lines = 0;
                level = 1;
                
                // Создаем первую фигуру и следующую фигуру
                const firstPieceIndex = Math.floor(Math.random() * pieces.length);
                player.matrix = createPiece(firstPieceIndex);
                console.log("Создана первая фигура с индексом:", firstPieceIndex);
                
                const nextPieceIndex = Math.floor(Math.random() * pieces.length);
                player.next = createPiece(nextPieceIndex);
                console.log("Создана следующая фигура с индексом:", nextPieceIndex);
                
                // Проверяем, что матрицы фигур созданы корректно
                if (!player.matrix || !Array.isArray(player.matrix) || player.matrix.length === 0) {
                    console.error("Ошибка: некорректная матрица текущей фигуры", player.matrix);
                    player.matrix = createPiece(0); // Создаем фигуру T как запасной вариант
                }
                
                if (!player.next || !Array.isArray(player.next) || player.next.length === 0) {
                    console.error("Ошибка: некорректная матрица следующей фигуры", player.next);
                    player.next = createPiece(0); // Создаем фигуру T как запасной вариант
                }
                
                // Устанавливаем начальную позицию
                player.pos.y = 0;
                player.pos.x = Math.floor((arena[0].length - player.matrix[0].length) / 2);
                console.log("Установлена начальная позиция:", player.pos);
                
                // Обновляем счет
                updateScore();
                
                // Сбрасываем флаги
                gameOver = false;
                paused = false;
                
                // Обновляем текст кнопки
                if (startButton) {
                    startButton.textContent = '⏸️ ПАУЗА';
                }
                
                // Сбрасываем счетчик падения
                dropCounter = 0;
                lastTime = 0;
                
                // Отрисовываем начальное состояние
                draw();
                
                console.log("Игра успешно инициализирована");
                return true;
            } catch (e) {
                console.error("Ошибка при инициализации игры:", e, "stack:", e.stack);
                return false;
            }
        }
        
        // Функция для запуска игры
        function startGame() {
            try {
                console.log("Запуск игры, текущее состояние: gameOver=" + gameOver + ", paused=" + paused + ", animationId=" + animationId);
                
                // Проверяем, что startButton определен
                if (!startButton) {
                    console.error("Ошибка: startButton не определен");
                    
                    // Пробуем получить startButton заново
                    startButton = document.getElementById('startButton');
                    
                    if (!startButton) {
                        console.error("Не удалось получить startButton");
                        return;
                    }
                }
                
                if (gameOver || animationId === null) {
                    console.log("Игра окончена или не запущена, инициализируем заново");
                    
                    // Инициализируем игру заново
                    const initSuccess = initGame();
                    
                    if (!initSuccess) {
                        console.error("Не удалось инициализировать игру");
                        
                        // Пробуем еще раз с небольшой задержкой
                        setTimeout(() => {
                            console.log("Повторная попытка инициализации игры");
                            const retrySuccess = initGame();
                            
                            if (retrySuccess) {
                                console.log("Повторная инициализация успешна, запускаем игровой цикл");
                                lastTime = 0;
                                dropCounter = 0;
                                
                                // Запускаем новый цикл
                                if (animationId !== null) {
                                    cancelAnimationFrame(animationId);
                                }
                                
                                animationId = requestAnimationFrame(update);
                                console.log("Новый animationId:", animationId);
                            } else {
                                console.error("Повторная инициализация не удалась");
                                
                                // Отображаем сообщение об ошибке
                                if (context) {
                                    context.fillStyle = 'rgba(0, 0, 0, 0.7)';
                                    context.fillRect(0, 0, canvas.width, canvas.height);
                                    
                                    context.font = '20px Arial';
                                    context.fillStyle = 'white';
                                    context.textAlign = 'center';
                                    context.fillText('Ошибка инициализации игры', canvas.width / 2, canvas.height / 2 - 30);
                                    context.fillText('Обновите страницу', canvas.width / 2, canvas.height / 2 + 30);
                                }
                            }
                        }, 500);
                        
                        return;
                    }
                    
                    // Запускаем игровой цикл
                    console.log("Запускаем новый игровой цикл");
                    lastTime = 0;
                    dropCounter = 0;
                    
                    // Убедимся, что предыдущий цикл остановлен
                    if (animationId !== null) {
                        cancelAnimationFrame(animationId);
                    }
                    
                    // Запускаем новый цикл
                    animationId = requestAnimationFrame(update);
                    console.log("Новый animationId:", animationId);
                } else if (paused) {
                    console.log("Игра на паузе, снимаем с паузы");
                    
                    // Снимаем с паузы
                    paused = false;
                    
                    // Обновляем текст кнопки
                    if (startButton) {
                        startButton.textContent = '⏸️ ПАУЗА';
                    }
                    
                    // Если анимация остановлена, запускаем её
                    if (animationId === null) {
                        console.log("Анимация остановлена, запускаем заново");
                        lastTime = 0;
                        animationId = requestAnimationFrame(update);
                        console.log("Возобновляем анимацию, новый animationId:", animationId);
                    }
                } else {
                    console.log("Игра уже запущена, ставим на паузу");
                    
                    // Ставим на паузу
                    paused = true;
                    
                    // Обновляем текст кнопки
                    if (startButton) {
                        startButton.textContent = '▶️ ПРОДОЛЖИТЬ';
                    }
                }
                
                console.log("После запуска: gameOver=" + gameOver + ", paused=" + paused + ", animationId=" + animationId);
            } catch (e) {
                console.error("Ошибка при запуске игры:", e, "stack:", e.stack);
                
                // Аварийный перезапуск
                gameOver = true;
                paused = false;
                
                // Обновляем текст кнопки
                if (startButton) {
                    startButton.textContent = '▶️ СТАРТ';
                }
                
                // Отображаем сообщение об ошибке
                if (context) {
                    context.fillStyle = 'rgba(0, 0, 0, 0.7)';
                    context.fillRect(0, 0, canvas.width, canvas.height);
                    
                    context.font = '20px Arial';
                    context.fillStyle = 'white';
                    context.textAlign = 'center';
                    context.fillText('Произошла ошибка', canvas.width / 2, canvas.height / 2 - 30);
                    context.fillText('Нажмите СТАРТ для новой игры', canvas.width / 2, canvas.height / 2 + 30);
                }
            }
        }
        
        // Обработчики событий
        // Обработчик клавиатуры
        document.addEventListener('keydown', event => {
            if (gameOver) return;
            
            switch (event.keyCode) {
                case 37: // Стрелка влево
                    playerMove(-1);
                    break;
                case 39: // Стрелка вправо
                    playerMove(1);
                    break;
                case 40: // Стрелка вниз
                    playerDrop();
                    break;
                case 38: // Стрелка вверх
                    playerRotate(1);
                    break;
                case 32: // Пробел
                    event.preventDefault();
                    playerHardDrop();
                    break;
                case 80: // Клавиша 'P'
                    togglePause();
                    break;
            }
        });
        
        // Переменные для обработки свайпов и тапов
        let touchStartX = 0;
        let touchStartY = 0;
        let touchEndX = 0;
        let touchEndY = 0;
        let lastTapTime = 0;
        
        // Минимальное расстояние для определения свайпа
        const minSwipeDistance = 30;
        
        // Обработчик двойного клика для запуска игры
        canvas.addEventListener('dblclick', function(event) {
            if (gameOver) {
                startGame();
            } else {
                togglePause();
            }
        });
        
        // Обработчики сенсорных событий для свайпов
        canvas.addEventListener('touchstart', function(event) {
            // Сохраняем координаты начала касания
            touchStartX = event.changedTouches[0].screenX;
            touchStartY = event.changedTouches[0].screenY;
            
            // Добавляем обработку двойного тапа
            const now = new Date().getTime();
            const timeSince = now - lastTapTime;
            
            if (timeSince < 300 && timeSince > 0) {
                // Двойной тап обнаружен
                if (gameOver) {
                    startGame();
                } else {
                    togglePause();
                }
                event.preventDefault();
            }
            
            lastTapTime = now;
        });
        
        canvas.addEventListener('touchmove', function(event) {
            // Предотвращаем прокрутку только если движение горизонтальное
            const touchX = event.changedTouches[0].screenX;
            const touchY = event.changedTouches[0].screenY;
            const deltaX = Math.abs(touchX - touchStartX);
            const deltaY = Math.abs(touchY - touchStartY);
            
            // Если движение больше горизонтальное, чем вертикальное
            if (deltaX > deltaY && deltaX > 10) {
                event.preventDefault();
            }
        }, { passive: false });
        
        canvas.addEventListener('touchend', function(event) {
            if (gameOver || paused) return;
            
            touchEndX = event.changedTouches[0].screenX;
            touchEndY = event.changedTouches[0].screenY;
            
            // Определяем, был ли это свайп или просто тап
            const deltaX = Math.abs(touchEndX - touchStartX);
            const deltaY = Math.abs(touchEndY - touchStartY);
            
            // Если было значительное движение, обрабатываем как свайп
            if (deltaX > 10 || deltaY > 10) {
                handleSwipe();
                event.preventDefault();
            }
        }, { passive: false });
        
        // Функция обработки свайпа
        function handleSwipe() {
            try {
                const deltaX = touchEndX - touchStartX;
                const deltaY = touchEndY - touchStartY;
                
                // Определяем, был ли свайп достаточно длинным
                if (Math.abs(deltaX) > minSwipeDistance || Math.abs(deltaY) > minSwipeDistance) {
                    // Определяем направление свайпа
                    if (Math.abs(deltaX) > Math.abs(deltaY)) {
                        // Горизонтальный свайп
                        if (deltaX > 0) {
                            // Свайп вправо - перемещаем на 1 клетку за раз, но быстрее
                            for (let i = 0; i < 3; i++) {
                                playerMove(1);
                            }
                        } else {
                            // Свайп влево - перемещаем на 1 клетку за раз, но быстрее
                            for (let i = 0; i < 3; i++) {
                                playerMove(-1);
                            }
                        }
                    } else {
                        // Вертикальный свайп
                        if (deltaY > 0) {
                            // Свайп вниз
                            playerHardDrop(); // Быстрое падение при свайпе вниз
                        } else {
                            // Свайп вверх
                            playerRotate(1); // Вращение при свайпе вверх
                        }
                    }
                }
            } catch (e) {
                console.error("Ошибка при обработке свайпа:", e);
            }
        }
        
        startButton.addEventListener('click', () => {
            if (gameOver) {
                startGame();
            } else {
                togglePause();
            }
        });
        
        // Обработчики для мобильных кнопок управления
        // Используем touchstart вместо click для более быстрого отклика
        
        const leftBtn = document.getElementById('left-btn');
        leftBtn.addEventListener('touchstart', (e) => {
            e.preventDefault();
            if (!gameOver && !paused) playerMove(-1);
        }, { passive: false });
        
        const rightBtn = document.getElementById('right-btn');
        rightBtn.addEventListener('touchstart', (e) => {
            e.preventDefault();
            if (!gameOver && !paused) playerMove(1);
        }, { passive: false });
        
        const downBtn = document.getElementById('down-btn');
        downBtn.addEventListener('touchstart', (e) => {
            e.preventDefault();
            if (!gameOver && !paused) playerDrop();
        }, { passive: false });
        
        const rotateBtn = document.getElementById('rotate-btn');
        rotateBtn.addEventListener('touchstart', (e) => {
            e.preventDefault();
            if (!gameOver && !paused) playerRotate(1);
        }, { passive: false });
        
        const dropBtn = document.getElementById('drop-btn');
        dropBtn.addEventListener('touchstart', (e) => {
            e.preventDefault();
            if (!gameOver && !paused) playerHardDrop();
        }, { passive: false });
        
        // Добавляем также обработчики click для поддержки всех устройств
        leftBtn.addEventListener('click', () => {
            if (!gameOver && !paused) playerMove(-1);
        });
        
        rightBtn.addEventListener('click', () => {
            if (!gameOver && !paused) playerMove(1);
        });
        
        downBtn.addEventListener('click', () => {
            if (!gameOver && !paused) playerDrop();
        });
        
        rotateBtn.addEventListener('click', () => {
            if (!gameOver && !paused) playerRotate(1);
        });
        
        dropBtn.addEventListener('click', () => {
            if (!gameOver && !paused) playerHardDrop();
        });
        
        // Добавляем обработчик для кнопки старта/паузы
        const startButton = document.getElementById('start-button');
        startButton.addEventListener('touchstart', (e) => {
            e.preventDefault();
            if (gameOver) {
                startGame();
            } else {
                togglePause();
            }
        }, { passive: false });
        
        // Добавляем также обработчик click для поддержки всех устройств
        startButton.addEventListener('click', () => {
            if (gameOver) {
                startGame();
            } else {
                togglePause();
            }
        });
        
        // Предотвращаем прокрутку страницы при нажатии на кнопки
        document.querySelectorAll('.mobile-controls button').forEach(button => {
            button.addEventListener('touchmove', e => e.preventDefault());
        });
        
        // Добавляем блестки на фон
        function createSparkles() {
            const container = document.querySelector('.game-container');
            for (let i = 0; i < 30; i++) {
                const sparkle = document.createElement('div');
                sparkle.classList.add('sparkle');
                sparkle.style.left = `${Math.random() * 100}%`;
                sparkle.style.top = `${Math.random() * 100}%`;
                sparkle.style.animationDelay = `${Math.random() * 2}s`;
                container.appendChild(sparkle);
            }
        }
        
        // Настройка размера холста для следующей фигуры
        nextCanvas.style.width = `${120}px`;
        nextCanvas.style.height = `${120}px`;
        
        // Создаем блестки
        createSparkles();
        
        // Инициализируем начальное состояние игры
        console.log("Инициализация начального состояния...");
        
        // Останавливаем предыдущий игровой цикл, если он был запущен
        if (animationId !== null) {
            cancelAnimationFrame(animationId);
            animationId = null;
        }
        
        // Очищаем арену
        arena.forEach(row => row.fill(0));
        
        // Сбрасываем счет
        player.score = 0;
        score = 0;
        lines = 0;
        level = 1;
        updateScore();
        
        // Создаем первую фигуру и следующую фигуру
        player.matrix = createPiece(Math.floor(Math.random() * pieces.length));
        player.next = createPiece(Math.floor(Math.random() * pieces.length));
        
        // Устанавливаем начальную позицию
        player.pos.y = 0;
        player.pos.x = Math.floor((arena[0].length - player.matrix[0].length) / 2);
        
        // Устанавливаем начальное состояние игры - игра не запущена
        gameOver = true;
        paused = false;
        startButton.textContent = '▶️ СТАРТ';
        
        // Отрисовываем начальное состояние
        draw();
        
        // Запускаем игровой цикл для отображения начального состояния
        lastTime = 0;
        animationId = requestAnimationFrame(update);
        
        console.log("Начальное состояние инициализировано");
        
        // Автоматический запуск игры на мобильных устройствах
        if (/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)) {
            // Небольшая задержка для загрузки всех ресурсов
            setTimeout(startGame, 1000);
            
            // Скрываем индикатор прокрутки после прокрутки
            const scrollIndicator = document.getElementById('scroll-indicator');
            if (scrollIndicator) {
                window.addEventListener('scroll', function() {
                    if (window.scrollY > 50) {
                        scrollIndicator.style.opacity = '0';
                        setTimeout(() => {
                            scrollIndicator.style.display = 'none';
                        }, 500);
                    }
                });
                
                // Скрываем индикатор через 5 секунд в любом случае
                setTimeout(() => {
                    scrollIndicator.style.opacity = '0';
                    setTimeout(() => {
                        scrollIndicator.style.display = 'none';
                    }, 500);
                }, 5000);
            }
        }
        
        // Автоматический запуск игры при загрузке страницы
        document.addEventListener('DOMContentLoaded', function() {
            console.log("DOM загружен, инициализируем игру...");
            
            // Отрисовываем начальное состояние
            draw();
            
            // Запускаем игру с небольшой задержкой, чтобы все элементы успели загрузиться
            setTimeout(function() {
                console.log("Автоматический запуск игры...");
                // Если игра еще не запущена, запускаем её
                if (gameOver || !animationId) {
                    startGame();
                }
            }, 500);
        });
    </script>
</body>
</html>